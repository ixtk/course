გაიხსენეთ და გაიაზრეთ როგორ მუშაობს სიის ფუნქცია `map`:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
https://www.w3schools.com/jsref/jsref_map.asp

თქვენი ამოცანაა დაწეროთ პატარა custom map ფუნქცია, რომელიც იმახსოვრებს წინა მნიშვნელობას და აბრუნებს ობიექტების სიას.

ჩვეულებრივი map-ისგან განსხვავებით, მხოლოდ ახალი შედეგის მაგივრად, custom map ფუნქციამ უნდა შეინახოს **ობიექტი**, სადაც `original` გასაღებზე არის ძველი, და `transformed` გასაღებზე ახალი მნიშვნელობა (ნახეთ მაგალითი).

ფუნქციას დაარქვით `historyMap`. არგუმენტებად უნდა გადაეცემოდეს სია და callback (ანუ ფუნქცია, რომელიც სიის თითოეული ელემენტისთვის შესრულდება). მაგალითად:

```js
const numbers = [1, 2, 3, 4]

// ჩვეულებრივი map-ით შეიქმნება სია [2, 4, 6, 8]
const newNumbersNormal = numbers.map((num) => num * 2)

// პირველი არგუმენტი: სია, მეორე არგუმენტი: ფუნქცია
const newNumbersCustom = historyMap(numbers, (num) => num * 2)

/*
custom historyMap-ით უნდა შეიქმნას სია

[
  { original: 1, transformed: 2 },
  { original: 2, transformed: 4 },
  { original: 3, transformed: 6 },
  { original: 4, transformed: 8 }
]
*/
```

(ჩვეულებრივი `map` callback ფუნქციას აწვდის ელემენტს, ინდექსს და მთლიან სიას. მაგრამ ამ დავალებისთვის საკმარისია მხოლოდ ელემენტის გადაცემა callback ფუნქციისთვის)

**მნიშვნელოვანია**: არ გამოიყენოთ javascript-ის `map` ან `forEach` ფუნქციები. გამოიყენეთ უბრალო `for` ციკლი.

თქვენი დავალებაა მხოლოდ `historyMap` ფუნქცია შექმნათ. მიბმულ ფაილში მოცემულია ამ ფუნქციის გამოყენების მაგალითები. შეგიძლიათ დატესტოთ ემთხვევა თუ არა თქვენი ფუნქციის შედეგი მოცემულ output-ს.

დასრულებულ დავალებაში უნდა იყოს ერთი ფუნქცია, `historyMap`, უნდა გქონდეთ გამოძახებული (შეგიძლიათ კოდის მაგალითებს მოხსნათ კომენტარი).

---

### დამატებითი განმარტება

ეს დავალება *არ* ეხება რომელიმე კონკრეტული სიის მოდიფიკაციას. მოცემულ კოდში რაცაა დაკომენტარებული უბრალოდ `historyMap`-ის გამოყენების მაგალითებია. მიზანი ისაა, რომ შექმნათ `historyMap`, რომელიც მუშაობს `map`-ის მსგავსად, გადაეცემა არგუმენტად სია და callback (ფუნქცია). **რა callback-იც არ უნდა მიიღოს**, ძველ და ახალ მნიშვნელობას ინახავს.

2-ზე გამრავლების, მომხმარებლის ინიციალების შეცვლის, და სხვა ნებისმიერი ნაწილი *არ* ეხება ამ დავალებას. თქვენი ამოცანაა მხოლოდ `historyMap` ფუნქცია შექმნათ.
